/*
|-----------------------------------------------------
| Start LEARN OOP 3:25PM at IFINANCE 
|-----------------------------------------------------
*/
#OOPs (Object-Oriented Programming System)
Object means a real-world entity such as a pen, chair, table, computer, watch, etc.
Object-Oriented Programming is a methodology or paradigm to design a program using classes and objects. 
1. Object
2. Class
3. Inheritance
4. Polymorphism
5. Abstraction
6. Encapsulation


Inheritance: When one object acquires all the properties and behaviors of a parent object, it is known as inheritance. It provides code reusability. It is used to achieve runtime polymorphism.
Polymorphism: If one task is performed in different ways, it is known as polymorphism. For example: to convince the customer differently, to draw something, for example, shape, triangle, rectangle, etc.
               Another example can be to speak something; for example, a cat speaks meow, dog barks woof, etc.	
Abstraction: Hiding internal details and showing functionality is known as abstraction. For example phone call, we don't know the internal processing.
            In Java, we use abstract class and interface to achieve abstraction.
			
Encapsulation: Binding (or wrapping) code and data together into a single unit are known as encapsulation. For example, a capsule, it is wrapped with different medicines.


Coupling:

Association: Association represents the relationship between the objects. Here one object can be associated with one object or many objects.
             There can be four types of association between the objects:
			 # One to One
			 # One to Many
			 # Many to One
			 # Many to Many
			 
What will we learn in OOPs Concepts?
   @ Advantage of OOPs
   @ Naming Convention 
   @ Object and class 
   @ Method overloading 
   @ Constructor
   @ static keyword 
   @ this keyword with six usage
   @ Inheritance 
   @ Aggregation 
   @ Method Overriding 
   @ Covariant Return Type 
   @ super keyword 
   @ Instance Initializer block 
   @ final keyword 
   @ Abstract class  
   @ Interface 
   @ Runtime Polymorphism 
   @ Static and Dynamic Binding
   @ Downcasting with instanceof operator
   @ Package
   @ Access Modifiers
   @ Encapsulation
   @ Object Cloning
   
   
   #Java Naming Convention
   All the classes, interfaces, packages, methods and fields of Java programming language are given according to the Java naming convention.
   If you fail to follow these conventions, it may generate confusion or erroneous code.
   
   Advantage of Naming Conventions in Java
   Class: It should start with the uppercase letter.
   Interface: It should start with the uppercase letter.
   Method: It should start with lowercase letter.
           If the name contains multiple words, start it with a lowercase letter followed by an uppercase letter such as actionPerformed()
	Variable: It should start with a lowercase letter such as id, name.
	           If the name contains multiple words, start it with the lowercase letter followed by an uppercase letter such as firstName, lastName.
			   
			   
	An object has three characteristics:
	State: represents the data (value) of an object.
	Behavior: represents the behavior (functionality) of an object such as deposit, withdraw, etc.
	Identity: An object identity is typically implemented via a unique ID. The value of the ID is not visible to the external user.
            	However, it is used internally by the JVM to identify each object uniquely.
				
	Object Definitions:
		#An object is a real-world entity.
		#An object is a runtime entity.
		#The object is an entity which has state and behavior.
		#The object is an instance of a class.
		
	A class in Java can contain:
		#Fields
		#Methods
		#Constructors
		#Nested class and interface
		
Syntax to declare a class:	
	class <class_name>{  
		field;  
		method;  
	}  
	
	
	#Method in Java
	In Java, a method is like a function which is used to expose the behavior of an object.
	#new keyword in Java
	The new keyword is used to allocate memory at runtime. All objects get memory in Heap memory area.

------Inheritance
	Inheritance in Java is a mechanism in which one object acquires all the properties and behaviors of a 		parent object. It is an important part of OOPs (Object Oriented programming system).
	When you inherit from an existing class, you can reuse methods and fields of the parent class. Moreover, 	you can add new methods and fields in your current class also.

----Terms used in Inheritance
	Class: A class is a group of objects which have common properties. It is a template or blueprint from 		which objects are created.
	Sub Class/Child Class: Subclass is a class which inherits the other class. It is also called a derived 				               class, extended class, or child class.
	Super Class/Parent Class: Superclass is the class from where a subclass inherits the features. It is also 				  called a base class or a parent class.
----The syntax of Java Inheritance
	class Subclass-name extends Superclass-name  
	{  
  		 //methods and fields  
	}  
	The extends keyword indicates that you are making a new class that derives from an existing class. The 	meaning of "extends" is to increase the functionality.

---Single Inheritance Example
	When a class inherits another class, it is known as a single inheritance. In the example given below, 
	Dog class inherits the Animal class, so there is the single inheritance.
	Example:
	class Animal{  
		void eat(){System.out.println("eating...");}  
	}  
	
	class Dog extends Animal{  
		void bark(){System.out.println("barking...");}  
	}  
	
	class TestInheritance{  
		public static void main(String args[]){  
			Dog d=new Dog();  
			d.bark();  
			d.eat();  
	}}  

Output:
barking...
eating...

------Multilevel Inheritance Example
When there is a chain of inheritance, it is known as multilevel inheritance.
BabyDog class inherits the Dog class which again inherits the Animal class, so there is a multilevel inheritance.
Example
class Animal{  
	void eat(){System.out.println("eating...");}  
}  
class Dog extends Animal{  
	void bark(){System.out.println("barking...");}  
}  
class BabyDog extends Dog{  
	void weep(){System.out.println("weeping...");}  
}  
class TestInheritance2{  
	public static void main(String args[]){  
			BabyDog d=new BabyDog();  
			d.weep();  
			d.bark();  
			d.eat();  
}}  
Output:

weeping...
barking...
eating...

----Hierarchical Inheritance Example
When two or more classes inherits a single class, it is known as hierarchical inheritance.
Dog and Cat classes inherits the Animal class, so there is hierarchical inheritance.

class Animal{  
	void eat(){System.out.println("eating...");}  
}  
class Dog extends Animal{  
	void bark(){System.out.println("barking...");}  
}  
class Cat extends Animal{  
	void meow(){System.out.println("meowing...");}  
}  
class TestInheritance3{  
	public static void main(String args[]){  
			Cat c=new Cat();  
			c.meow();  
			c.eat();  
			//c.bark();//C.T.Error  
}} 


-----Aggregation in Java
If a class have an entity reference, it is known as Aggregation 
Example
class Operation{  
 int square(int n){  
  return n*n;  
 }  
}  
  
class Circle{  
 Operation op;//aggregation  
 double pi=3.14;  
    
 double area(int radius){  
   op=new Operation();  
   int rsquare=op.square(radius);//code reusability (i.e. delegates the method call).  
   return pi*rsquare;  
 }  
  
     
    
 public static void main(String args[]){  
   Circle c=new Circle();  
   double result=c.area(5);  
   System.out.println(result);  
 }  
}  

Output:78.5

When use Aggregation?
Code reuse is also best achieved by aggregation when there is no is-a relationship.
Example:
	#Address.java
	public class Address {  
		String city,state,country;  
  
		public Address(String city, String state, String country) {  
				this.city = city;  
				this.state = state;  
				this.country = country;  
			}  
  
	}  
	
	#Emp.java
	public class Emp {  
		int id;  
		String name;  
		Address address;  
  
		public Emp(int id, String name,Address address) {  
			this.id = id;  
			this.name = name;  
			this.address=address;  
		}  
  
		void display(){  
			System.out.println(id+" "+name);  
			System.out.println(address.city+" "+address.state+" "+address.country);  
		}  
  
		public static void main(String[] args) {  
				Address address1=new Address("gzb","UP","india");  
				Address address2=new Address("gno","UP","india");  
  
				Emp e=new Emp(111,"varun",address1);  
				Emp e2=new Emp(112,"arun",address2);  
      
				e.display();  
				e2.display();  
      
		}  
	}  
	
	Output:111 varun
			gzb UP india
			112 arun
			gno UP india 
			
--Example 04: Multiple Inheritance (Through Interfaces)
	using System;
interface IMother {
	public void DisplayParents() { }
	public void DisplayMother() { }
}
interface IFather {
	public void DisplayParents() { }
	public void DisplayFather() { }
}
class Child : IMother, IFather {
	public void DisplayParents() { // implements the interface's method
	Console.WriteLine("Here are my parents");
}
public void DisplayMother() { // implements the Mother interface's method
	Console.WriteLine("Here is my mother");
}

public void DisplayFather() { // implements the Father interface's method
	Console.WriteLine("Here is my father");
}
	public void DisplayChild()
	{
	Console.WriteLine("I am a child");
	}
	}
class Program {
static void Main(string[] args)
{
Child child = new Child();
child.DisplayChild();
child.DisplayMother();
child.DisplayFather();
child.DisplayParents();
Console.ReadKey();
}
}



Example 05: Multiple Inheritance (Through Interfaces)
using System;
interface IMother
{
	public void DisplayParents();
	public void DisplayMother();
}

interface IFather
{
	public void DisplayParents();
	public void DisplayFather();
}

class Child : IMother, IFather
{
	public void DisplayParents()
	{ // implements the interface's method
	Console.WriteLine("Here are my parents");
}

public void DisplayMother()
{ // implements the Mother interface's method
	Console.WriteLine("Here is my mother");
}

public void DisplayFather()
{ // implements the Father interface's method
	Console.WriteLine("Here is my father");
}
public void DisplayChild()
{
	Console.WriteLine("I am a child");
}
}
class Program
{
	static void Main(string[] args)
	{
		IMother child1 = new Child();
		child1.DisplayChild(); //Error
		child1.DisplayMother();
		child1.DisplayFather(); //Error
		child1.DisplayParents();
		IFather child2 = new Child();
		child2.DisplayChild(); //Error
		child2.DisplayMother(); //Error
		child2.DisplayFather();
		child2.DisplayParents();
		Child child3 = new Child();
		child3.DisplayChild();
		child3.DisplayMother();
		child3.DisplayFather();
		child3.DisplayParents();
		Console.ReadKey();
	}
}



Example 05: Hybrid Inheritance
using System;
class Grandparent
{
	public void DisplayGrandparent()
	{
		Console.WriteLine("Here is my Grandparent");
	}
}
class Parent : Grandparent
{
	public void DisplayParent()
		{
			Console.WriteLine("Here is my parent");
		}
}
class ChildA : Parent
{
	public void DisplayChildA()
	{
		Console.WriteLine("I am the child A");
	}
}
class ChildB : Parent
{
	public void DisplayChildB()
		{
		Console.WriteLine("I am the child B");
		}
}

class Program
{
	public static void Main(string[] args)
	{
		ChildA childA = new ChildA();
		ChildB childB = new ChildB();
		childA.DisplayChildA();
		childA.DisplayParent(); // accessing parent class
		childA.DisplayGrandparent(); // accessing Grandparent class
		childB.DisplayChildB();
		childB.DisplayParent(); // accessing parent class
		childB.DisplayGrandparent(); // accessing Grandparent class
		Console.ReadKey();
	}
}
Output
I am the child A
Here is my parent
Here is my Grandparent
I am the child B
Here is my parent
Here is my Grandparent

In above example, multilevel and hierarchical inheritance both are mixed:
- Multilevel Inheritance: ChildA class inherits Parent class which inherits Grandparent class.
ChildB class inherits Parent class which inherits Grandparent class.
- Hierarchical Inheritance: ChildA and ChildB both inherit Parent class.


Example 07: Hybrid Inheritance (Through Interfaces)
using System;
interface IGrandparent
{
	public void DisplayGrandparent(){ }
}

interface IMother : IGrandparent
{
	public void DisplayMother(){ }
}

interface IFather : IGrandparent
{
	public void DisplayFather() { }
}
class Child : IMother, IFather
{
	public void DisplayGrandparent()
	{
		Console.WriteLine("Here is my Grandparent");
	}
	public void DisplayFather()
	{
		Console.WriteLine("Here is my father");
	}
	public void DisplayMother()
	{
		Console.WriteLine("Here is my mother");
	}
	public void DisplayChild()
	{
		Console.WriteLine("I am a child");
	}
}
class Program
{
public static void Main(string[] args)
{
Child child = new Child();
child.DisplayChild();
child.DisplayMother();
child.DisplayFather();
child.DisplayGrandparent();
Console.ReadKey();
}
}
25
Chea Daly OOAD
Output
I am a child
Here is my mother
Here is my father
Here is my Grandparent
In above example, hierarchical and multiple inheritance both are mixed:
- Hierarchical Inheritance: Mother and Father interfaces both inherit Grandparent interface.
- Multiple Inheritance: Child class inherits both Mother and Father interfaces.
- Multilevel Inheritance: Child class inherits Mother class which inherits Grandparent class.
Child class inherits Father class which inherits Grandparent class.

------Encapsulation
Encapsulation means hiding or covering. In C#, encapsulation is achieved by access modifiers. Access modifiers specify the accessibility of an object and all of its members
You can also limit access to class members. For example, you might need to keep the BankAccount class public for some reason, but make the AccountBalance field and TaxRate field and GetBalanceAfterTax() method private so that no other class can access these class members except the BankAccount class. You can do this as follows:
Example 01:
public class BankAccount
{
	private double AccountBalance;
	private double TaxRate;
	private double GetBalanceAfterTax()
			{
			return AccountBalance * TaxRate;
			}
}

-Access Modifiers
The access modifiers that are available in C# are the following:
• private
• public
• protected
• internal
• protected internal
• private protected

private Access Modifiers:
Objects that implement private access modifier are accessible only inside a class. As a result, we cannot access them outside the class they are created.
Example 02: In this example, we declare a field as private
using System;
class NumberClass
{
	private int number = 10;
}

class Program
{
	static void Main()
	{
		NumberClass num = new NumberClass();
		Console.WriteLine(num.number); // Error. We cannot access the number variable
		// because it has the private access modifier and its only accessible in the
		// NumberClass class
	}
}


-public Access Modifiers
Objects that implement public access modifiers are accessible from everywhere in our project
Example 04: In this example, we declare a class member as public
using System;
class NumberClass
{
public int number = 10;
}
class Program
{
static void Main()
{
NumberClass num = new NumberClass();
Console.WriteLine(num.number); // This is OK. The number variable has the public
// access modifier.
Console.ReadKey();
}
}
Output
10